{
    "baseline": [
        "Chunk ID 271: A container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:",
        "Chunk ID 272: A container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:",
        "Chunk ID 273: A container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages",
        "Chunk ID 269: ConfigMaps consumed as environment variables are not updated automatically and require a pod restart.\n\n\nA container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps",
        "Chunk ID 270: ConfigMaps consumed as environment variables are not updated automatically and require a pod restart.\n\n\nA container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their"
    ],
    "hyde": [
        "Chunk ID 301: The following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages\n- improves performance of your cluster by significantly reducing load on kube-apiserver, by\nclosing watches for ConfigMaps marked as immutable.\n\nYou can create an immutable ConfigMap by setting the `immutable` field to `true`.\nFor example:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n...\ndata:\n...\nimmutable: true\n```\n\nOnce a ConfigMap is marked as immutable, it is _not_ possible to revert this change\nnor to mutate the contents of the `data` or the `binaryData` field. You can\nonly delete and recreate the ConfigMap. Because existing Pods maintain a mount point\nto the deleted ConfigMap, it is recommended to recreate these pods.\n\n##\n\n* Read about [Secrets](/docs/concepts/configuration/secret/).\n* Read [Configure a Pod to Use a ConfigMap](/docs/tasks/configure-pod-container/configure-pod-configmap/).\n* Read about [changing a ConfigMap (or any other Kubernetes object)](/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/)\n* Read [The Twelve-Factor App](https://12factor.net/) to understand the motivation for\nseparating code from configuration.",
        "⚠️ Chunk ID 300 not found in metadata.",
        "⚠️ Chunk ID 296 not found in metadata.",
        "Chunk ID 293: apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages\n- improves performance of your cluster by significantly reducing load on kube-apiserver, by\nclosing watches for ConfigMaps marked as immutable.\n\nYou can create an immutable ConfigMap by setting the `immutable` field to `true`.\nFor example:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n...\ndata:\n...\nimmutable: true\n```\n\nOnce a ConfigMap is marked as immutable, it is _not_ possible to revert this change\nnor to mutate the contents of the `data` or the `binaryData` field. You can\nonly delete and recreate the ConfigMap. Because existing Pods maintain a mount point\nto the deleted ConfigMap, it is recommended to recreate these pods.\n294\tkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages\n- improves performance of your cluster by significantly reducing load on kube-apiserver, by\nclosing watches for ConfigMaps marked as immutable.\n\nYou can create an immutable ConfigMap by setting the `immutable` field to `true`.\nFor example:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n...\ndata:\n...\nimmutable: true\n```\n\nOnce a ConfigMap is marked as immutable, it is _not_ possible to revert this change\nnor to mutate the contents of the `data` or the `binaryData` field. You can\nonly delete and recreate the ConfigMap. Because existing Pods maintain a mount point\nto the deleted ConfigMap, it is recommended to recreate these pods.\n\n295\tmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages\n- improves performance of your cluster by significantly reducing load on kube-apiserver, by\nclosing watches for ConfigMaps marked as immutable.\n\nYou can create an immutable ConfigMap by setting the `immutable` field to `true`.\nFor example:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n...\ndata:\n...\nimmutable: true\n```\n\nOnce a ConfigMap is marked as immutable, it is _not_ possible to revert this change\nnor to mutate the contents of the `data` or the `binaryData` field. You can\nonly delete and recreate the ConfigMap. Because existing Pods maintain a mount point\nto the deleted ConfigMap, it is recommended to recreate these pods.\n\n##\n296\t  name: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages\n- improves performance of your cluster by significantly reducing load on kube-apiserver, by\nclosing watches for ConfigMaps marked as immutable.\n\nYou can create an immutable ConfigMap by setting the `immutable` field to `true`.\nFor example:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n...\ndata:\n...\nimmutable: true\n```\n\nOnce a ConfigMap is marked as immutable, it is _not_ possible to revert this change\nnor to mutate the contents of the `data` or the `binaryData` field. You can\nonly delete and recreate the ConfigMap. Because existing Pods maintain a mount point\nto the deleted ConfigMap, it is recommended to recreate these pods.\n\n##\n\n297\tdata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages\n- improves performance of your cluster by significantly reducing load on kube-apiserver, by\nclosing watches for ConfigMaps marked as immutable.\n\nYou can create an immutable ConfigMap by setting the `immutable` field to `true`.\nFor example:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n...\ndata:\n...\nimmutable: true\n```\n\nOnce a ConfigMap is marked as immutable, it is _not_ possible to revert this change\nnor to mutate the contents of the `data` or the `binaryData` field. You can\nonly delete and recreate the ConfigMap. Because existing Pods maintain a mount point\nto the deleted ConfigMap, it is recommended to recreate these pods.\n\n##\n\n* Read about [Secrets](/docs/concepts/configuration/secret/).\n298\t  username: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages\n- improves performance of your cluster by significantly reducing load on kube-apiserver, by\nclosing watches for ConfigMaps marked as immutable.\n\nYou can create an immutable ConfigMap by setting the `immutable` field to `true`.\nFor example:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n...\ndata:\n...\nimmutable: true\n```\n\nOnce a ConfigMap is marked as immutable, it is _not_ possible to revert this change\nnor to mutate the contents of the `data` or the `binaryData` field. You can\nonly delete and recreate the ConfigMap. Because existing Pods maintain a mount point\nto the deleted ConfigMap, it is recommended to recreate these pods.\n\n##\n\n* Read about [Secrets](/docs/concepts/configuration/secret/).\n* Read [Configure a Pod to Use a ConfigMap](/docs/tasks/configure-pod-container/configure-pod-configmap/).\n299\t  access_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages\n- improves performance of your cluster by significantly reducing load on kube-apiserver, by\nclosing watches for ConfigMaps marked as immutable.\n\nYou can create an immutable ConfigMap by setting the `immutable` field to `true`.\nFor example:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n...\ndata:\n...\nimmutable: true\n```\n\nOnce a ConfigMap is marked as immutable, it is _not_ possible to revert this change\nnor to mutate the contents of the `data` or the `binaryData` field. You can\nonly delete and recreate the ConfigMap. Because existing Pods maintain a mount point\nto the deleted ConfigMap, it is recommended to recreate these pods.\n\n##\n\n* Read about [Secrets](/docs/concepts/configuration/secret/).\n* Read [Configure a Pod to Use a ConfigMap](/docs/tasks/configure-pod-container/configure-pod-configmap/).\n* Read about [changing a ConfigMap (or any other Kubernetes object)](/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/)\n300\t```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages\n- improves performance of your cluster by significantly reducing load on kube-apiserver, by\nclosing watches for ConfigMaps marked as immutable.\n\nYou can create an immutable ConfigMap by setting the `immutable` field to `true`.\nFor example:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n...\ndata:\n...\nimmutable: true\n```\n\nOnce a ConfigMap is marked as immutable, it is _not_ possible to revert this change\nnor to mutate the contents of the `data` or the `binaryData` field. You can\nonly delete and recreate the ConfigMap. Because existing Pods maintain a mount point\nto the deleted ConfigMap, it is recommended to recreate these pods.\n\n##\n\n* Read about [Secrets](/docs/concepts/configuration/secret/).\n* Read [Configure a Pod to Use a ConfigMap](/docs/tasks/configure-pod-container/configure-pod-configmap/).\n* Read about [changing a ConfigMap (or any other Kubernetes object)](/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/)\n* Read [The Twelve-Factor App](https://12factor.net/) to understand the motivation for",
        "Chunk ID 291: ```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages\n- improves performance of your cluster by significantly reducing load on kube-apiserver, by\nclosing watches for ConfigMaps marked as immutable.\n\nYou can create an immutable ConfigMap by setting the `immutable` field to `true`.\nFor example:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n...\ndata:\n...\nimmutable: true\n```\n\nOnce a ConfigMap is marked as immutable, it is _not_ possible to revert this change\nnor to mutate the contents of the `data` or the `binaryData` field. You can\n292\t```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages\n- improves performance of your cluster by significantly reducing load on kube-apiserver, by\nclosing watches for ConfigMaps marked as immutable.\n\nYou can create an immutable ConfigMap by setting the `immutable` field to `true`.\nFor example:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n...\ndata:\n...\nimmutable: true\n```\n\nOnce a ConfigMap is marked as immutable, it is _not_ possible to revert this change\nnor to mutate the contents of the `data` or the `binaryData` field. You can\nonly delete and recreate the ConfigMap. Because existing Pods maintain a mount point"
    ],
    "hyde_query": "### Problem Description\n\nIn a Kubernetes environment, you have deployed a Node.js application that is expected to read a configuration file located at `/app/config.json`. This configuration file is intended to be provisioned through a **ConfigMap**, which is a Kubernetes resource designed to manage non-confidential configuration data in a key-value pair format. However, upon deploying the application, you encounter a **pod start failure** where the application crashes with an error stating that it cannot find the required configuration file. This situation typically triggers a **FailedMount** event, which indicates that the specified ConfigMap could not be mounted to the desired path within the pod.\n\n### Key Issues\n\n1. **Missing ConfigMap:**\n   - The primary cause of the failure is that the ConfigMap referenced in the pod specification is not found or does not exist in the Kubernetes namespace where the pod is deployed.\n   - This may occur if the ConfigMap was never created, was deleted inadvertently, or if there's a typo in the name of the ConfigMap.\n\n2. **Volume Mount Failures:**\n   - The pod specification likely includes a `volumeMount` configuration that attempts to mount the ConfigMap using the field `subPath` to specifically place the file at `/app/config.json`.\n   - If the ConfigMap is missing, Kubernetes cannot create the expected volume mount, leading to the application not having access to the essential configuration file, which results in an error such as `ENOENT` (Error NO ENTry), indicating that the specified file could not be found.\n\n3. **Incorrect Path Configurations:**\n   - There might be an issue with the path specified in the `subPath` field. If the ConfigMap is present but the expected key name or file path does not match with what the application expects, this issue could occur as well.\n\n### Contextual Details\n\n- **Deployment Configurations:**\n  The deployment YAML should include a volume definition for the ConfigMap and a corresponding volume mount. A snippet would look something like this:\n\n    ```yaml\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      name: my-node-app\n    spec:\n      replicas: 1\n      template:\n        spec:\n          containers:\n          - name: node-app\n            image: my-node-app-image\n            volumeMounts:\n              - name: config-volume\n                mountPath: /app/config.json\n                subPath: config.json\n          volumes:\n            - name: config-volume\n              configMap:\n                name: my-config-map\n    ```\n\n- **Error Messages:**\n  When the application attempts to start, it typically raises an error message similar to:\n  ```\n  Error: ENOENT: no such file or directory, open '/app/config.json'\n  ```\n\n### Possible Causes\n\n1. **ConfigMap Not Created:** \n   The ConfigMap has not been created or was applied to the wrong namespace.\n\n2. **Deletion of ConfigMap:**\n   The ConfigMap was deleted after the pod was initially set up, leading to a mismatch when the pod tries to mount it.\n\n3. **Incorrect Namespacing:**\n   The deployment and ConfigMap might be in different namespaces, or the service account used may not have the necessary permissions to access the ConfigMap.\n\n4. **Typographical Error:** \n   There could be a typo in the name of the ConfigMap in the pod spec.\n\n5. **Missing Key in ConfigMap:**\n   The key `config.json` is not present within the ConfigMap, even if it is created.\n\n### Effects\n\n- **Application Crash:**\n  The failure to find the configuration file leads to the application crashing immediately on startup. This can have cascading effects on your service availability, particularly in production environments.\n\n- **Failed Mount Events:**\n  Kubernetes will record `FailedMount` events in the pod status, which indicates to the user that the mounting operation could not be completed.\n\n- **Increased Debugging Time:**\n  Developers and DevOps engineers will need to spend additional time diagnosing the issue, potentially causing delays to deployment schedules and operations.\n\n### Potential Solutions\n\n1. **Verify ConfigMap Creation:**\n   - Check if the ConfigMap exists in the expected namespace using:\n     ```bash\n     kubectl get configmaps -n <namespace>\n     ```\n\n2. **Create the ConfigMap:**\n   - If the ConfigMap does not exist, create it using a YAML or command line, for example:\n     ```bash\n     kubectl create configmap my-config-map --from-file=config.json=<path-to-your-file> -n <namespace>\n     ```\n\n3. **Inspect Pod Spec:**\n   - Review the pod specification for any typographical errors in the ConfigMap name or the `subPath`.\n\n4. **Check Namespace Consistency:**\n   - Ensure that both the pod and ConfigMap are in the same namespace, and that proper RBAC permissions are in place if using a custom service account.\n\n5. **Log and Event Checking:**\n   - Use:\n     ```bash\n     kubectl describe pod <pod-name> -n <namespace>\n     ```\n   - to review the detailed events that may point towards more underlying issues.\n\nBy addressing the root cause of the ConfigMap issues and ensuring that it is correctly referenced and mounted, you can resolve the pod start failure and enable the Node.js application to function as expected.",
    "zero_shot": [
        "Chunk ID 271: A container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:",
        "Chunk ID 272: A container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:",
        "Chunk ID 273: A container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages",
        "Chunk ID 269: ConfigMaps consumed as environment variables are not updated automatically and require a pod restart.\n\n\nA container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps",
        "Chunk ID 270: ConfigMaps consumed as environment variables are not updated automatically and require a pod restart.\n\n\nA container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their"
    ],
    "few_shot": [
        "Chunk ID 271: A container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:",
        "Chunk ID 272: A container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:",
        "Chunk ID 273: A container using a ConfigMap as a [subPath](/docs/concepts/storage/volumes#using-subpath) volume mount will not receive ConfigMap updates.\n\n\n\n### Using Configmaps as environment variables\n\nTo use a Configmap in an\nin a Pod:\n\n1. For each container in your Pod specification, add an environment variable\nfor each Configmap key that you want to use to the\n`env[].valueFrom.configMapKeyRef` field.\n1. Modify your image and/or command line so that the program looks for values\nin the specified environment variables.\n\nThis is an example of defining a ConfigMap as a pod environment variable:\n\nThe following ConfigMap (myconfigmap.yaml) stores two properties: username and access_level:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: myconfigmap\ndata:\nusername: k8s-admin\naccess_level: \"1\"\n```\n\nThe following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages",
        "Chunk ID 301: The following command will create the ConfigMap object:\n\n```shell\nkubectl apply -f myconfigmap.yaml\n```\n\nThe following Pod consumes the content of the ConfigMap as environment variables:\n\n\n\nThe `envFrom` field instructs Kubernetes to create environment variables from the sources nested within it.\nThe inner `configMapRef` refers to a ConfigMap by its name and selects all its key-value pairs.\nAdd the Pod to your cluster, then retrieve its logs to see the output from the printenv command.\nThis should confirm that the two key-value pairs from the ConfigMap have been set as environment variables:\n\n```shell\nkubectl apply -f env-configmap.yaml\n```\n```shell\nkubectl logs pod/ env-configmap\n```\nThe output is similar to this:\n```console\n...\nusername: \"k8s-admin\"\naccess_level: \"1\"\n...\n```\n\nSometimes a Pod won't require access to all the values in a ConfigMap.\nFor example, you could have another Pod which only uses the username value from the ConfigMap.\nFor this use case, you can use the `env.valueFrom` syntax instead, which lets you select individual keys in\na ConfigMap. The name of the environment variable can also be different from the key within the ConfigMap.\nFor example:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: env-configmap\nspec:\ncontainers:\n- name: envars-test-container\nimage: nginx\nenv:\n- name: CONFIGMAP_USERNAME\nvalueFrom:\nconfigMapKeyRef:\nname: myconfigmap\nkey: username\n```\n\nIn the Pod created from this manifest, you will see that the environment variable\n`CONFIGMAP_USERNAME` is set to the value of the `username` value from the ConfigMap.\nOther keys from the ConfigMap data are not copied into the environment.\n\n\nIt's important to note that the range of characters allowed for environment\nvariable names in pods is [restricted](/docs/tasks/inject-data-application/define-environment-variable-container/#using-environment-variables-inside-of-your-config).\nIf any keys do not meet the rules, those keys are not made available to your container, though\nthe Pod is allowed to start.\n\n## Immutable ConfigMaps {#configmap-immutable}\n\n\n\nThe Kubernetes feature _Immutable Secrets and ConfigMaps_ provides an option to set\nindividual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps\n(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their\ndata has the following advantages:\n\n- protects you from accidental (or unwanted) updates that could cause applications outages\n- improves performance of your cluster by significantly reducing load on kube-apiserver, by\nclosing watches for ConfigMaps marked as immutable.\n\nYou can create an immutable ConfigMap by setting the `immutable` field to `true`.\nFor example:\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n...\ndata:\n...\nimmutable: true\n```\n\nOnce a ConfigMap is marked as immutable, it is _not_ possible to revert this change\nnor to mutate the contents of the `data` or the `binaryData` field. You can\nonly delete and recreate the ConfigMap. Because existing Pods maintain a mount point\nto the deleted ConfigMap, it is recommended to recreate these pods.\n\n##\n\n* Read about [Secrets](/docs/concepts/configuration/secret/).\n* Read [Configure a Pod to Use a ConfigMap](/docs/tasks/configure-pod-container/configure-pod-configmap/).\n* Read about [changing a ConfigMap (or any other Kubernetes object)](/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/)\n* Read [The Twelve-Factor App](https://12factor.net/) to understand the motivation for\nseparating code from configuration.",
        "⚠️ Chunk ID 296 not found in metadata."
    ]
}