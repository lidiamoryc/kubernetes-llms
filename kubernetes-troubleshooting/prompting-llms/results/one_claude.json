[
  "1. DNS for Services\n\"Kubernetes offers a DNS cluster addon Service that automatically assigns dns names to other Services. You can check if it's running on your cluster.\"\nhttps://kubernetes.io/docs/concepts/services-networking/dns-pod-service/\n\n2. Service Discovery\n\"Kubernetes supports 2 primary modes of finding a Service - environment variables and DNS.\"\nhttps://kubernetes.io/docs/concepts/services-networking/service/#discovering-services\n\n3. Container Probes \n\"The kubelet uses liveness probes to know when to restart a container. For example, liveness probes could catch a deadlock, where an application is running, but unable to make progress.\"\nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes\n\n4. Probe Configuration\n\"Probes have a number of fields that you can use to more precisely control the behavior of liveness and readiness checks: initialDelaySeconds, timeoutSeconds, periodSeconds, failureThreshold, successThreshold\"",
  "1. Volumes\n\"On-disk files in a container are ephemeral, which presents some problems for non-trivial applications when running in containers. One problem is the loss of files when a container crashes. The kubelet restarts the container but with a clean state.\"\nhttps://kubernetes.io/docs/concepts/storage/volumes/\n\n2. ConfigMaps \n\"ConfigMaps allow you to decouple configuration artifacts from image content to keep containerized applications portable. The ConfigMap API resource stores configuration data as key-value pairs.\"\nhttps://kubernetes.io/docs/concepts/configuration/configmap/\n\n3. Mounting ConfigMaps into Pods\n\"You can mount a ConfigMap into a Pod using a volume. This allows config files stored in the ConfigMap to be accessible by applications in the Pod.\"\nhttps://kubernetes.io/docs/concepts/configuration/configmap/#using-configmaps-as-files-from-a-pod\n\n4. ConfigMap Usage\n\"When a ConfigMap already being consumed in a volume is updated, projected keys are eventually updated as well. The kubelet checks whether the mounted ConfigMap is fresh on every periodic sync.\"",
  "Here are some relevant Kubernetes documentation excerpts related to the provided error symptoms and configuration:\n\n1. Pod Probes\n\"Probes have a number of fields that you can use to more precisely control the behavior of liveness and readiness checks...use `timeoutSeconds` to specify the number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1.\"\nhttps://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/\n\n2. Environment Variables\n\"When you create a Pod, you can set environment variables for the containers that run in the Pod. To set environment variables, include the `env` or `envFrom` field in the configuration file.\"\nhttps://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/\n\n3. Container Images\n\"The `imagePullPolicy` and the tag of the image affect when the kubelet attempts to pull the specified image. `Always`: Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest.\"\nhttps://kubernetes.io/docs/concepts/containers/images\n\n4. Container Lifecycle Hooks \n\"There are two hooks that are exposed to Containers: PostStart which executes immediately after a container is created and PreStop which is blocking and is called immediately before a container is terminated.\"\nhttps://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/",
  "1. Resource Limits\n\"When you specify a Pod, you can optionally specify how much of each resource a Container needs. The most common resources to specify are CPU and memory (RAM).\"\nhttps://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\n\n2. Container Memory Limits\n\"If the node has enough memory, the containers are allowed to use more memory. However, containers are not allowed to use more than their resource limit.\"\nhttps://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/\n\n3. OOMKilled Pod Status\n\"If a Pod is taking up more memory than its limit, the Pod becomes a candidate for termination. If the terminated Pod can be restarted, the kubelet restarts it, as with any other type of runtime failure.\"\nhttps://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#how-pods-with-resource-limits-are-run\n\n4. Node Allocatable Memory\n\"Node Allocatable is feature that reserves compute resources for system daemons and the kubelet. Allocatable is the amount of resources available for scheduling. Reserve memory using the --kube-reserved and --system-reserved kubelet flags.\"",
  "Here are some relevant Kubernetes documentation excerpts for this case:\n\n1. Pod Environment Variables\n\"Environment variables defined in a Pod specification can be used by containers within that Pod. This includes passing configuration details to applications.\"\nhttps://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/\n\n2. Startup Probe Timeouts\n\"Your application might require an external service before it starts, such as a database. Use initialDelaySeconds to provide sufficient time for dependencies to initialize.\"  \nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#when-should-you-use-a-startup-probe\n\n3. Probes and Service Dependencies  \n\"Probes that check dependencies need sufficient timeouts. Consider both the initialDelaySeconds and periodSeconds fields to prevent premature probe failure.\" \nhttps://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#probe-timeouts\n\n4. Pod Failures and Restarts\n\"Pods can fail for many reasons, such as Probe failures or container crashes. The control plane attempts to automatically restart failed containers based on the restartPolicy.\"",
  "Here are some relevant Kubernetes documentation excerpts for the provided error details:\n\n1. Pod Probe Configuration\n\"Probes have a number of fields that you can use to more precisely control the behavior of liveness and readiness checks:\n   - timeoutSeconds: Number of seconds after which the probe times out. Defaults to 1 second.\"\nhttps://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes \n\n2. Defining a Liveness Command\n\"Many applications running for long periods of time eventually transition to broken states, and cannot recover except by being restarted. Kubernetes provides liveness probes to detect and remedy such situations.\"\nhttps://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-liveness-command\n\n3. Probe Timeouts\n\"The timeoutSeconds field specifies how long kubelet should wait before marking the probe as failed, defaulting to 1 second. This value must be greater than the time the probe itself takes to complete, otherwise the probe will time out before getting a chance to succeed.\"\n\n4. Dependency Checks & Startup Probes \n\"Sometimes, you have to deal with legacy applications that might require an additional startup time on their first initialization. In such cases, it can be tricky to set up liveness probe parameters without compromising the fast response to deadlocks that motivated such a probe. The trick is to set up a startup probe with the same command, HTTP or TCP check, with a failureThreshold * periodSeconds long enough to cover the worse case startup time.\"\nhttps://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes"
]